Product Requirements Document (PRD): Algo Royale
Project Name	Algo Royale
Version	1.1 (The "Golden Ticket" Update)
Status	Approved for Dev
Visual Style	Retro 8-Bit / Arcade / CRT Terminal
Data Source	Static JSON (LeetCode/CF Dump)
1. Executive Summary
Algo Royale is a 1v1 real-time coding battle with a "Clash Royale" meta. Players compete in a Best-of-3 format where solving a problem destroys an opponent's "Tower." Uniquely, Mana (Elixir) is generated by coding activity, rewarding high APM (Actions Per Minute) and flow state, which is used to sabotage the opponent.

2. Core Gameplay Loop: "The Tower System"
The match is divided into 3 distinct Rounds (Problems).

The Crown System:

1 Problem Solved = 1 Tower Destroyed.

Unlike a standard contest, you don't wait for the timer. The moment Player A passes all test cases, Player B's tower collapses (visualized as an 8-bit tower crumbling), and the round ends immediately.

Winning the Match:

The player with the most Towers destroyed at the end of 3 problems wins.

Sudden Death: If the score is 1-1 going into Round 3, the winner of the 3rd problem takes the "King Tower" and wins the game.

3. The "Active Mana" System (New)
Mana is required to use Sabotage Cards. Instead of passive regeneration, mana is earned through Productivity.

Mana Cap: 5 Mana (Max).

Regeneration Logic (The "Flow" Engine):

Passive Regen: 0 (Or extremely slow, e.g., 1 Mana every 30s).

Active Regen: Mana fills based on Keystrokes and New Lines.

Formula: 20 valid characters typed = +0.5 Mana.

Anti-Spam: Repeatedly smashing "asdf" or "Enter" is detected by a simple heuristic (e.g., checking for variety in characters or language keywords like int, for, return).

Strategic Twist: A faster typist earns mana faster, allowing them to "Blind" their opponent more often. This rewards technical speed.

4. Sabotage Cards (Deck)
Since Max Mana is 5, costs are scaled down.

Card	Cost	Effect	Visual Effect
Fog	2	Blurs opponent's editor for 5s.	Heavy gray pixel dither over code.
Freeze	3	Disables typing for 3s.	Blue ice block overlay.
Shuffle	4	Swaps 2 random lines of code.	"Glitch" RGB split effect.
Shield	3	Blocks next attack (Lasts 10s).	Green bubble around avatar.
5. Technical Architecture
5.1. Data Source: "The Golden Ticket"

Source: Static JSON file (e.g., merged_problems.json) hosted in the project or Supabase Storage.

Database Schema (Supabase):

Table: problems

Columns:

id (int)

title (text)

description_html (text) - Sanitized

difficulty (text) - Easy/Medium/Hard

sample_input (text)

sample_output (text)

Fetching:

On Game Start, the server queries the DB:

SELECT * FROM problems WHERE difficulty = 'Easy' LIMIT 1 (Round 1)

SELECT * FROM problems WHERE difficulty = 'Medium' LIMIT 1 (Round 2)

SELECT * FROM problems WHERE difficulty = 'Hard' LIMIT 1 (Round 3)

5.2. Judge System (MVP)

Local Judge / Simple Match:

Because we are using a Static JSON, we likely only have the Sample Cases.

Validation: User code output is compared strictly against sample_output.

Note: For MVP, if they pass the sample cases, we count it as a "Solve/Tower Destroyed."

6. UI Layout (The Arena)
Plaintext
[ PLAYER 1 (YOU) ]                       [ OPPONENT ]
-------------------------------------------------------
|  MANA: [==== ] (4/5)  |       |  STATUS: Typing...  |
|  [Fog][Freeze][Swap]  |       |  HP: [Alive]        |
-------------------------------------------------------
|                       |       |                     |
|    CODE EDITOR        |       |    PROBLEM DESC     |
|    (Monaco)           |       |    (Retro Font)     |
|                       |       |                     |
-------------------------------------------------------
|  CONSOLE / OUTPUT     |       |   TOWER SCORE       |
|  > Compiling...       |       |   [ ðŸ‘‘ ] [ âŒ ]     |
-------------------------------------------------------
7. Implementation Roadmap
Phase 1: Setup: Initialize Next.js, Supabase, and load the JSON problems into the DB.

Phase 2: The Editor: Get Monaco working and hook up the "Keyup" listener to the "Mana Bar" state.

Phase 3: Multiplayer: Connect Socket.io. When Player A clicks "Freeze", send event -> Player B receives freeze.

Phase 4: The Judge: Simple string comparison of Code Output vs Expected Output.